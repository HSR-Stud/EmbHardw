\section{Avalon Interface}
	The Avalon interface allows you to interconnect components in Intel FPGAs using Qsys via the Avalon Bus.
	
	\subsection{Interface Types \avIntSp{4}}
		A single component can have any number of Avalon Interfaces, and also multiple instances of the same interface type. The available interface types are:
			\begin{longtable}{|>{\bfseries}p{0.3\linewidth}|p{0.65\linewidth}|}
				\hline
				Streaming Interface
					& Supports the unidirectional flow of data.\\
				\hline
				Memory Mapped Interface
					& Supports address-based read/write behaviour for master-slave connections.\\
				\hline
				Conduit Interface
					& Supports individual signals or signal groups that do not finto any other Avalon type.
					These signals can be interconnected inside a Qsys system or exported to other modules or FPGA pins.\\
				\hline
				Tri-State Conduit Interface
					& Supports off-chip peripherals. Multiple peripherals can share pins through signal multiplexing.\\
				\hline
				Interrupt Interface
					& Supports interrupts in order to signal events to other components.\\
				\hline
				Clock Interface
					& Drives or receives clocks.\\
				\hline
				Reset Interface
					& drives or receives resets.\\
				\hline	
			\end{longtable}
		
	\subsection{Avalon Memory Mapped Interface \avIntSp{13}}
		Memory mapped interfaces are components that are mapped into the global memory space. Typically the necessary amount of memory equals the space required by the component's registers. The system allocates the amount of memory to the component as can be addressed by the width of the address bus input. If the component is a memory mapped memory, the address directly represents the address location of the data (not a register).
			
		\subsubsection{Avalon MM Signals \avIntSp{15-19} \weekPageMaehne{3}{8}}
			%Some remarks to Avalon MM Signals. For a complete listing see \avIntSp{15-19}.
			\begin{longtable}{|p{0.12\linewidth}||p{0.22\linewidth}|p{0.56\linewidth}|}					
				\hline
				\textbf{Signal}
					& \textbf{Description}
					& \textbf{Remarks}\\
				\hhline{|=#=|=|}
				\texttt{address}
					& The address which is read or written to. 
					&   \textbf{Master:} The global address space unique address needs to be set.
					
					  	\textbf{Slave:} Only the component internally unique address (last few bits) are visible at the slave address input.\\
				\hline
				\texttt{write}
					& Signals a write transfer.
					& At the rising edge all signals necessary for the transfer are asserted.\\
				\hline
				\texttt{writeData}
					& Data to write.
					& Data is set for one cycle.\\
				\hline
				\texttt{read}
					& Signals a read transfer.
					& At the rising edge all signals necessary for the transfer are asserted.\\
				\hline
				\texttt{readData}
					& Data being read.
					& Data is set for one cycle.\\
				\hline
				\texttt{waitRequest}
					& Signals that transfer can not be responded to yet.
					& Asserted by the slave when it is unable to respond to a \texttt{read} or \texttt{write} request. Forces the master to wait until slave is ready. Master must not change output to the slave until \texttt{waitRequest} is deasserted.\\
				\hline
				\texttt{readDataValid}
					& When asserted, \texttt{readData} contains valid data.
					& Must be asserted for $n$ clock cycles (not necessarily consecutively) for each of the $n$ \texttt{readData} terms of a burst transfer.\\
				\hline
			\end{longtable}
		
		\subsubsection{Read and Write Transfers with fixed cycle-delay \avIntSp{27} \weekPageMaehne{3}{10}}
		\begin{multicols}{2}
			\begin{compactenum}
				\item \texttt{address}, \texttt{byteenable} and \texttt{read} are asserted after the rising edge of \texttt{clk}.
				\item The next rising edge of \texttt{clk} mrarks the end of the first and only wait-state-cycle. The \texttt{readWaitTime} is 1.
				\item The Slave asserts \texttt{readData} and \texttt{response}.
				\item \texttt{readData} and \texttt{response} are read by the master, completing the transfer.
				
				\item \texttt{address}, \texttt{byteenable} and \texttt{write} are asserted after the rising edge of \texttt{clk}.
				\item Slave reads \texttt{writeData}. The write transfer ends after 2 wait-state cycles.
			\end{compactenum}
			\begin{tikztimingtable}
				\texttt{clk} 			& LHLHLHLHLHLHL \\
				\texttt{address} 		& UDDDDUUDDDDUU \\
				\texttt{byteenable} 	& UDDDDUUDDDDUU \\
				\texttt{read} 			& LHHHHLLLLLLLL \\
				\texttt{write} 			& LLLLLLLHHHHLL \\
				\texttt{readData}		& UUUDDUUUUUUUU \\
				\texttt{response}		& UUUDDUUUUUUUU \\
				\texttt{writeData}		& UUUUUUUDDDDUU \\
				\extracode
				% Add vertical lines in two colors
				\begin{pgfonlayer}{background}
					% Add background grid lines
					\begin{scope}[gray,semitransparent,semithick,dotted]
						\vertlines{1,3,5,7,9,11,13}
					\end{scope}
				\end{pgfonlayer}
			\end{tikztimingtable} \\
		\end{multicols}
			
		\subsubsection{Read and Write Transfers with \texttt{waitRequest} \avIntSp{23} \weekPageMaehne{3}{11}}	
			\begin{multicols}{2}
				\begin{compactenum}
					\item \texttt{address}, \texttt{byteenable} and \texttt{read} are asserted after the rising edge of \texttt{clk}.
					\item Slave asserts \texttt{waitRequest}.
					\item Master waits.
					\item Slave deasserts \texttt{waitRequest} after the rising edge of clk. \texttt{readData} and \texttt{response} are set by the slave at the same time.
					\item \texttt{readData} and \texttt{response} are read by the master, completing the transfer.
					  
					\item \texttt{address}, \texttt{byteenable} and \texttt{write} are asserted after the rising edge of \texttt{clk}.
					\item Slave asserts \texttt{waitRequest}.
					\item Master waits.
					\item Slave deasserts \texttt{waitRequest} after the rising edge of clk.
					\item Slave reads \texttt{writeData}. \texttt{writeData} is valid until the next rising edge of \texttt{clk} after \texttt{waitRequest} is deasserted.
				\end{compactenum}
			\begin{tikztimingtable}
				\texttt{clk} 			& LHLMLHLHLMLHLMLHLHLHL \\
				\texttt{address} 		& UDDMDDDUUUUMUDDMDDDUU \\
				\texttt{byteenable} 	& UDDMDDDUUUUMUDDMDDDUU \\
				\texttt{read} 			& LHHMHHHLLLLMLLLMLLLLL \\
				\texttt{write} 			& LLLMLLLLLLLMLHHMHHHLL \\
				\texttt{waitRequest}	& LHHMHLLLLLLMLHHMHLLLL \\
				\texttt{readData}		& UUUMUUUDDUUMUUUMUUUUU \\
				\texttt{response}		& UUUMUUUDDUUMUUUMUUUUU \\
				\texttt{readDataValid}	& LLLMLLLHHLLMLLLMLLLLL \\
				\texttt{writeData}		& UUUMUUUUUUUMUDDMDDDUU \\
				\extracode
				% Add vertical lines in two colors
				\begin{pgfonlayer}{background}
					% Add background grid lines
					\begin{scope}[gray,semitransparent,semithick,dotted]
						\vertlines{1,3,5,7,9,11,13,15,17,19}
					\end{scope}
				\end{pgfonlayer}
			\end{tikztimingtable}	\\ \\ \\ \\ \\
		\end{multicols}			

		
		
		\subsubsection{Avalon MM Slave}
			
			\lstinputlisting[style=VHDL, caption=simplePIO]{./src/simplePIO.vhdl}
			
		\subsubsection{Avalon MM Master}
		
		
		
			